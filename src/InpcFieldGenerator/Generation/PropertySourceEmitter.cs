using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace InpcFieldGenerator.Generation;

internal static class PropertySourceEmitter
{
    internal static string Emit(INamedTypeSymbol typeSymbol, ImmutableArray<PropertyGenerationModel> properties)
    {
        var builder = new IndentedStringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            var namespaceName = EmitterUtilities.FormatNamespace(typeSymbol.ContainingNamespace);
            builder.AppendLine($"namespace {namespaceName};");
            builder.AppendLine();
        }

        var containingTypes = GetContainingTypes(typeSymbol);

        foreach (var symbol in containingTypes)
        {
            var accessibility = EmitterUtilities.FormatAccessibility(symbol.DeclaredAccessibility);
            var keyword = EmitterUtilities.FormatTypeKeyword(symbol);
            var typeParameters = EmitterUtilities.FormatTypeParameterList(symbol);
            var constraints = EmitterUtilities.FormatTypeConstraints(symbol);

            builder.AppendLine($"{accessibility} partial {keyword} {symbol.Name}{typeParameters}{constraints}");
            builder.AppendLine("{");
            builder.IncreaseIndent();
        }

        for (var index = 0; index < properties.Length; index++)
        {
            var model = properties[index];

            WriteProperty(builder, model);

            if (index < properties.Length - 1)
            {
                builder.AppendLine();
            }
        }

        for (var i = containingTypes.Count - 1; i >= 0; i--)
        {
            builder.DecreaseIndent();
            builder.AppendLine("}");
        }

        return builder.ToString();
    }

    private static void WriteProperty(IndentedStringBuilder builder, PropertyGenerationModel model)
    {
        builder.AppendLine($"public partial {model.PropertyTypeDisplay} {model.PropertyName}");
        builder.AppendLine("{");
        builder.IncreaseIndent();
        builder.AppendLine("get => field;");
        builder.AppendLine("set");
        builder.AppendLine("{");
        builder.IncreaseIndent();

        if (model.GenerateEqualityCheck)
        {
            builder.AppendLine($"if (global::System.Collections.Generic.EqualityComparer<{model.PropertyTypeDisplay}>.Default.Equals(field, value))");
            builder.AppendLine("{");
            builder.IncreaseIndent();
            builder.AppendLine("return;");
            builder.DecreaseIndent();
            builder.AppendLine("}");
        }

        var propertyLiteral = EmitterUtilities.CreateStringLiteral(model.PropertyName);

        if (model.NotifyOnChanging && model.ChangingNotificationMember is not null)
        {
            builder.AppendLine($"this.{model.ChangingNotificationMember}({propertyLiteral});");
        }

        builder.AppendLine("field = value;");
        builder.AppendLine($"this.{model.ChangedNotificationMember}({propertyLiteral});");

        foreach (var notification in model.AdditionalNotifications)
        {
            builder.AppendLine($"this.{model.ChangedNotificationMember}({EmitterUtilities.CreateStringLiteral(notification)});");
        }

        builder.DecreaseIndent();
        builder.AppendLine("}");
        builder.DecreaseIndent();
        builder.AppendLine("}");
    }

    private static List<INamedTypeSymbol> GetContainingTypes(INamedTypeSymbol typeSymbol)
    {
        var stack = new Stack<INamedTypeSymbol>();
        var current = typeSymbol;

        while (current is not null)
        {
            stack.Push(current);
            current = current.ContainingType;
        }

        return stack.ToList();
    }
}
